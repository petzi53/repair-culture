---
title: "Explorative Data Analysis"
author: "[Peter Baumgartner](https://github.com/petzi53)"
date: "Last updated: `r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    css: style.css
    theme: united
    toc: true
    pandoc_args: --number-offset=1,0
    toc_float:
      collapsed: false
      smooth_scroll: true
    toc_depth: 3
    number_sections: false
    code_folding: hide
    code_download: true
bibliography: references.bib
link-citations: true
---

```{r setup}
library(tidyverse)
library(repairData)

knitr::opts_chunk$set(echo = TRUE) 

```

## Name of variables and factor levels

```{r glimpse-data}
data(repairs)
glimpse(repairs)
```

## Shorten some column names

For less typing I will shorten some variable names.


```{r shorten-col-names}
repair_df <- repairs |> 
  rename(end_of_life_barrier = repair_barrier_if_end_of_life) |> 
  rename(product_description = partner_product_category) |> 
  rename(group_id = group_identifier)
glimpse(repair_df)
```

## Convert "????" to NA

The variable year_of_manufacture has "????" as NA. This is not a usable value for graphs, especially as the variable should be numerical e.g. an integer.

I will substitute "????" with the standard `NA` code. For this purpose I was planning to use the `naniar` package. It has the function replace_with_na(). The vignette [Replacing values with NA](http://naniar.njtierney.com/articles/replace-with-na.html) explains how to use it.


```{r replace-with-na}
library(naniar)

repair_tst <- repair_df |>
  replace_with_na(replace = list(year_of_manufacture = '????'))

glimpse(repair_tst)
```

This works. But I also wanted to change year_of_manufacture to a variable type integer. If I am using the base R function `as.integer()` all values that are not convertible, e.g., are not a number stored as character string, will be coerced to NA's. Many times this side effect is not desired and therefore `as_integer()` (and friends) was developed. This set of underscore coercion functions (`as_logical()`, `as_integer()`, `as_character()` etc.) is soft-deprecated recently with `vec_cast()`, a function from the vector helpers package `vctrs`. But in my case this side effect is just the desired behavior!

```{r convert-year-to-integer, warning=TRUE}
repair_df <- repair_df |> 
  mutate(year_of_manufacture = as.integer(year_of_manufacture)) 

glimpse(repair_df)
```

## Revise factor levels


The variable `end_of_life_barrier` is in `r count(repair_df, end_of_life_barrier)[1,2]` cases empty. The reasons are twofold:

1. The variable is only applicable when repair_status has the value "End of Life".
2. Values are missing, even if repair_status = "End of Life".

I will clarify this situation by imputing
1. "not applicable" in all those case where `repair_status` is NOT "End of Life" and
2. `NA` whenever `repair_status` IS "End of Life" and the field is empty. 

To add new values for factors needs an extra step: The creation of a new level (category) with this value. To make my above outlined changes I convert `end_of_life_barrier` therefore temporarily to a character variable.


```{r}
repair_df <- repair_df |> 
  mutate(end_of_life_barrier = as.character(end_of_life_barrier)) |> 
  mutate(end_of_life_barrier = 
           replace(end_of_life_barrier, 
                   repair_status == "End of life" &
                   end_of_life_barrier == "", NA)) |> 
  mutate(end_of_life_barrier = 
           replace(end_of_life_barrier, 
                   repair_status != "End of life", 
                   "not applicable")) |> 
  mutate(end_of_life_barrier = factor(end_of_life_barrier))
glimpse(repair_df)
```

## Show all factor levels

```{r show-all-factor-levels}

repair_df %>% purrr::map(levels)
```


## Skim all variables

```{r}
library(skimr)

skim(repair_df)
```


